# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import base64
import hashlib
import math
import json
import time
import datetime
import jwt
import hmac
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import RequestTimeout
from ccxt.base.errors import InvalidAddress
from requests.exceptions import HTTPError, Timeout, TooManyRedirects, RequestException
from ssl import SSLError

from ccxt.base.decimal_to_precision import ROUND
from ccxt.base.decimal_to_precision import TRUNCATE
from ccxt.base.decimal_to_precision import SIGNIFICANT_DIGITS


class fcoin (Exchange):

    def describe(self):
        return self.deep_extend(super(fcoin, self).describe(), {
            'id': 'fcoin',
            'name': 'Fcoin',
            'countries': 'NA',
            'version': 'v1',
            'rateLimit': 10,
            # new metainfo interface
            'has': {
                'CORS': False,
                'createDepositAddress': False,
                'deposit': False,
                'fetchClosedOrders': True,
                'fetchDepositAddress': False,
                'fetchTradingFees': False,
                'fetchFundingFees': False,
                'fetchMyTrades': False,
                'fetchOHLCV': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchTickers': False,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '3h': '3h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '7D',
                '2w': '14D',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://www.fcoin.com/static/images/logo_beta.png',
                'api': 'https://api.fcoin.com/v2',
                'www': 'https://www.fcoin.com/',
                'doc': [
                    'https://developer.fcoin.com/zh.html',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'public/server-time',
                        'public/symbols',
                        'public/currencies',
                        'market/ticker/{symbol}',
                        'market/depth/{level}/{symbol}',
                        'market/trades/{symbol}',
                        'market/candles/{resolution}/{symbol}',
                    ],
                },
                'private': {
                    'get': [
                        'accounts/balance',
                        'orders',
                        'orders/{id}',
                        'orders/{id}/match-results'
                    ],
                    'post': [
                        'orders',
                        'orders/{id}/submit-cancel',
                    ],
                },
            },
            'fees': {
            },
            'commonCurrencies': {
            },
            'exceptions': {
            },
            'precisionMode': SIGNIFICANT_DIGITS,
        })

    def fetch_markets(self):
        markets = self.publicGetPublicSymbols()
        result = []
        for market in markets["data"]:
            id = market['name']
            baseId = market['base_currency']
            quoteId = market['quote_currency']
            base = self.common_currency_code(baseId)
            quote = self.common_currency_code(quoteId)
            symbol = base.upper() + '/' + quote.upper()
            precision = {
                'base': market['amount_decimal'],
                'quote': market['price_decimal'],
                'amount': market['amount_decimal'],
                'price': market['price_decimal'],
            }

            limits = {
                'amount': {
                    'min': math.pow(10, -precision['amount']),
                    'max': None,
                },
                'price': {
                    'min': math.pow(10, -precision['price']),
                    'max': None,
                },

            }

            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': True,
                'precision': precision,
                'limits': limits,
                'info': market,
            })
        return result

    def cost_to_precision(self, symbol, cost):
        return self.decimal_to_precision(cost, ROUND, self.markets[symbol]['precision']['price'], self.precisionMode)

    def price_to_precision(self, symbol, price):
        return self.decimal_to_precision(price, ROUND, self.markets[symbol]['precision']['price'], self.precisionMode)

    def amount_to_precision(self, symbol, amount):
        return self.decimal_to_precision(amount, TRUNCATE, self.markets[symbol]['precision']['amount'], self.precisionMode)

    def fee_to_precision(self, currency, fee):
        return self.decimal_to_precision(fee, ROUND, self.currencies[currency]['precision'], self.precisionMode)

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetAccountsBalance(params)

        result = {'info': response}
        balances = response['data']
        for balance in balances:
            currency = balance['currency'].upper()
            if currency in self.currencies_by_id:
                currency = self.currencies_by_id[currency]['code']
            account = {
                'free': float(balance['available']),
                'used': float(balance['frozen']),
                'total': float(balance['balance']),
            }
            result[currency] = account
        return self.parse_balance(result)

    def cancel_order(self, id, symbol=None, params={}):
        if symbol is not None:
            print("symbol param is not supported in bigone!")

        response = self.privatePostOrdersIdSubmitCancel(self.extend({
            'id': id,
        }, params))
        return response

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        method = 'privatePostOrders'

        order = {
            'symbol': market['id'],
            'price': self.price_to_precision(symbol, price),
            'amount': self.amount_to_string(symbol, amount),
            'side': side.lower(),
            'type': type,
        }

        response = getattr(self, method)(self.extend(order, params))

        _order = {
            "info": response,
            "id": response["data"],
            "type": type,
            "amount": amount,
            "price": price,
            "state": "submitted"
        }

        return self.parse_order(_order)

    def fetch_order(self, order_id, symbol=None, params={}):
        if symbol is not None:
            print("symbol param is not supported in bigone!")
        self.load_markets()
        market = self.markets[symbol] if symbol else None
        request = {
            'id': order_id,
        }

        response = self.privateGetOrdersId(self.extend(request, params))
        return self.parse_order(response["data"], market)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        if not symbol:
            raise ExchangeError(self.id + ' fetchClosedOrders requires a symbol param')
        orders = self.fetch_orders(symbol, since, limit, params)
        return self.filter_by(orders, 'status', 'closed')

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        if not symbol:
            raise ExchangeError(self.id + ' fetchOpenOrders requires a symbol param')
        orders = self.fetch_orders(symbol, since, limit, params)
        return self.filter_by(orders, 'status', 'open')

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if not symbol:
            raise ExchangeError(self.id + ' fetchOrders requires a symbol param')
        self.load_markets()
        market = self.market(symbol)

        request = {
            'symbol': market['id'],
            'states': "submitted,partial_filled,partial_canceled,filled,canceled"
        }

        response = self.privateGetOrders(self.extend(request, params))

        result = self.safe_value(response, "data")

        return self.parse_orders(result, market, since, limit)

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }

        if limit is not None and isinstance(limit, int):
            request['limit'] = limit

        response = self.publicGetMarketTradesSymbol(self.extend(request, params))

        result = self.safe_value(response, "data")

        return self.parse_trades(result, market, since, limit)

    def fetch_order_book(self, symbol, limit="L20", params={}):
        self.load_markets()
        market = self.market(symbol)

        if limit not in ["L20", "L100", "full"]:
            print("fcoin limit param only support L20, L100, full")
            print("auto switch to L20")
            limit = "L20"

        request = {
            'symbol': market['id'],
            'level': str(limit),
        }

        response = self.publicGetMarketDepthLevelSymbol(self.extend(request, params))
        response = self.order_book_format(response["data"])

        timestamp = self.safe_integer(response, "ts")

        orderbook = self.parse_order_book(response, timestamp=timestamp)
        return orderbook

    @staticmethod
    def order_book_format(response):

        for side in ["asks","bids"]:
            _order_books = []
            while response[side]:
                _order_book = []
                for i in range(2):
                    _order_book.append(response[side].pop())
                _order_books.append(_order_book)
            response[side] = _order_books

        return response

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        response = self.publicGetMarketTickerSymbol(self.extend({
            'symbol': market['id'],
        }, params))

        return self.parse_ticker(response["data"], market)

    def parse_ticker(self, ticker, market=None):
        timestamp = self.milliseconds()
        iso8601 = None if (timestamp is None) else self.iso8601(timestamp)
        symbol = self.find_symbol(self.safe_string(ticker, 'type')[7:], market)
        ticker = ticker['ticker']
        last = self.safe_float(ticker, 0)
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': iso8601,
            'high': self.safe_float(ticker, 7),
            'low': self.safe_float(ticker, 8),
            'bid': self.safe_float(ticker, 2),
            'bidVolume': self.safe_float(ticker, 3),
            'ask': self.safe_float(ticker, 4),
            'askVolume': self.safe_float(ticker, 5),
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': self.safe_float(ticker, 6),  # previous day close
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 9),
            'quoteVolume': self.safe_float(ticker, 10),
            'info': ticker,
        }

    def parse_trade(self, trade, market=None):
        timestamp = trade['ts']
        priceField = 'price'
        price = float(trade[priceField])
        amountField = 'amount'
        amount = float(trade[amountField])
        idField = 'id'
        id = str(trade[idField])
        side = self.safe_string(trade, 'side')
        order = None
        if 'orderId' in trade:
            order = str(trade['orderId'])

        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'id': id,
            'order': order,
            'type': None,
            'takerOrMaker': None,
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'fee': None,
        }

    def parse_order_status(self, status):
        statuses = {
            'partial_filled': 'open',
            'submitted': 'open',
            'pending_cancel': 'canceled',
            'partial_canceled': 'canceled',
            'filled': 'closed',
            'canceled': 'canceled',
        }
        return statuses[status] if (status in list(statuses.keys())) else status.lower()

    def parse_order(self, order, market=None):
        status = self.safe_value(order, 'state')
        info = order['info'] if 'info' in order else order
        if status is not None:
            status = self.parse_order_status(status)
        symbol = self.find_symbol(self.safe_string(order, 'symbol'), market)

        timestamp = self.safe_value(order, 'created_at')
        iso8601 = self.iso8601(timestamp)
        last_trade_timestamp = self.safe_value(order, 'updated_at')

        price = self.safe_float(order, 'price')
        amount = self.safe_float(order, 'amount')
        filled = self.safe_float(order, 'filled_amount', 0.0)
        remaining = None
        cost = None
        if filled is not None:
            if amount is not None:
                remaining = max(amount - filled, 0.0)
            if price is not None:
                cost = price * filled
        id = self.safe_string(order, 'id')
        type = self.safe_string(order, 'type')
        if type is not None:
            type = type.lower()
        side = self.safe_string(order, 'side')
        if side is not None:
            side = side.lower()

        result = {
            'info': info,
            'id': id,
            'timestamp': timestamp,
            'datetime': iso8601,
            'lastTradeTimestamp': last_trade_timestamp,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': None,
        }
        return result

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = '/' + self.implode_params(path, params)
        full_url = self.urls['api'] + url

        param=''
        if params:
            sort_pay = sorted(params.items())
            #sort_pay.sort()
            for k in sort_pay:
                param += '&' + str(k[0]) + '=' + str(k[1])
            param = param.lstrip('&')

        headers = {
            'Content-Type': 'application/json',
        }

        timestamp = str(self.milliseconds())
        if api == 'public':
            if param:
                full_url += '?' + param
            sig_str = method + full_url + timestamp
        else:
            self.check_required_credentials()
            if method == 'GET':
                if param:
                    full_url += '?' + param
                sig_str = method + full_url + timestamp
            else:
                sig_str = method + full_url + timestamp + param

            sig_str = bytes(sig_str, 'utf-8')
            sig_str = base64.b64encode(sig_str)
            signature = base64.b64encode(hmac.new(bytes(self.secret, 'utf-8'), sig_str, digestmod=hashlib.sha1).digest())

            headers['FC-ACCESS-KEY'] = bytes(self.apiKey, 'utf-8')
            headers['FC-ACCESS-SIGNATURE'] = signature
            headers['FC-ACCESS-TIMESTAMP'] = timestamp

        return {'url': full_url, 'method': method, 'body': body, 'headers': headers, 'json': params}

    def fetch2(self, path, api='public', method='GET', params={}, headers=None, body=None):
        """A better wrapper over request for deferred signing"""
        if self.enableRateLimit:
            self.throttle()
        self.lastRestRequestTimestamp = self.milliseconds()
        request = self.sign(path, api, method, params, headers, body)
        return self.fetch(request['url'], request['method'], request['headers'], request['body'], request['json'])

    def fetch(self, url, method='GET', headers=None, body=None, json=None):
        """Perform a HTTP request and return decoded JSON data"""
        request_headers = self.prepare_request_headers(headers)
        url = self.proxy + url

        if self.verbose:
            print("\nRequest:", method, url, request_headers, body, json)

        self.logger.debug("%s %s, Request: %s %s", method, url, request_headers, body)

        if body:
            body = body.encode()

        self.session.cookies.clear()

        response = None
        try:
            response = self.session.request(
                method,
                url,
                data=body,
                json=json,
                headers=request_headers,
                timeout=int(self.timeout / 1000),
                proxies=self.proxies
            )
            self.last_http_response = response.text
            self.last_response_headers = response.headers
            if self.verbose:
                print("\nResponse:", method, url, str(response.status_code), str(response.headers), self.last_http_response)
            # self.logger.debug("%s %s, Response: %s %s %s", method, url, response.status_code, response.headers, self.last_http_response)
            self.logger.debug("%s %s, Response: %s %s ", method, url, response.status_code, response.headers)
            response.raise_for_status()

        except Timeout as e:
            self.raise_error(RequestTimeout, method, url, e)

        except TooManyRedirects as e:
            self.raise_error(ExchangeError, url, method, e)

        except SSLError as e:
            self.raise_error(ExchangeError, url, method, e)

        except HTTPError as e:
            self.handle_errors(response.status_code, response.reason, url, method, self.last_response_headers, self.last_http_response)
            self.handle_rest_errors(e, response.status_code, self.last_http_response, url, method)
            self.raise_error(ExchangeError, url, method, e, self.last_http_response)

        except RequestException as e:  # base exception class
            self.raise_error(ExchangeError, url, method, e, self.last_http_response)

        self.handle_errors(response.status_code, response.reason, url, method, None, self.last_http_response)
        return self.handle_rest_response(self.last_http_response, url, method, headers, body)

    def handle_errors(self, code, reason, url, method, headers, body):
        response = json.loads(body)
        if (code == 418) or (code == 429):
            raise DDoSProtection(self.id + ' ' + str(code) + ' ' + reason + ' ' + body)

        if "errors" in response:
            errors = self.safe_value(response, 'errors')

            for error in errors:    
                error_code = self.safe_string(error, "code")
                error_msg = self.safe_string(error, "message")
                
                exceptions = self.exceptions
                if error_code in exceptions:
                    raise exceptions[error_code](error_msg)
                else:
                    raise ExchangeError(error_msg)
            